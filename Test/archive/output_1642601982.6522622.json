{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}, "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_CreateUser>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpc3rrrnoy\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027806CE2DC0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_CreateUser", "rerun": "0"}}, "suite_name": "test_CreateUser.py"}, "1": {"suite_name": "test_CreateUser_Without_Mandatory_Field.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_CreateUserWithoutMandatoryField>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpoj3tg15m\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807339280>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_CreateUserWithoutMandatoryField", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "2": {"suite_name": "test_Edit_Manage_Address_Books.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Edit_Manage_Address_Books>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpf0ctzzi6\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807407A60>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Edit_Manage_Address_Books", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "3": {"suite_name": "test_Example.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_setUpClass>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmph75eqov6\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807407820>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_setUpClass", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "4": {"suite_name": "test_Find_Product.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_FindProduct>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpkx8p5rsz\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807407C10>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_FindProduct", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "5": {"suite_name": "test_Give_Review.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Give_Review>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpfp9sz1ih\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807407B80>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Give_Review", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "6": {"suite_name": "test_Load_Shopping_Cart.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_LoadShoppingCart>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpr3o70y0p\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807407E50>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_LoadShoppingCart", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "7": {"suite_name": "test_Login.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Login>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpgr6e7qjz\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x000002780734FA60>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Login", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "8": {"suite_name": "test_Make_Purchase.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_MakePurchase>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmprfsmolc2\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278072F0CA0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_MakePurchase", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "9": {"suite_name": "test_Order_By_Name.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Order_By_Name>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpkkze0iau\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B5430>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Order_By_Name", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "10": {"suite_name": "test_Product_Of_Stock.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Product_Of_Stock>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpau6fy4tq\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B55E0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Product_Of_Stock", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "11": {"suite_name": "test_Show_Elements_Menu.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_ShowElementsMenu>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmp8j4kmyjj\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B5790>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_ShowElementsMenu", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "12": {"suite_name": "test_Show_Footer_Elements.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_ShowFooterElements>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpf762js9u\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B5040>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_ShowFooterElements", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "13": {"suite_name": "test_SwitchBetweenThreeWindows.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_SwitchBetweenThreeWindows>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpt0nck1pt\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B50D0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_SwitchBetweenThreeWindows", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "14": {"suite_name": "test_SwitchBetweenTwoWindows.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_SwitchBetweenTwoWindows>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmp72xklvq5\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B5160>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_SwitchBetweenTwoWindows", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "15": {"suite_name": "test_Verifiy_Currency_Exchange.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_ContactUsForm>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpclmxn7_p\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x00000278074B5310>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_ContactUsForm", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "16": {"suite_name": "test_Verify_BannersHomePage.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_BannersHomePage>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmp64ung3s4\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442160>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_BannersHomePage", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "17": {"suite_name": "test_Verify_Color_Hover_All_Boxes.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Color_Hover_All_Boxes>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmptg0261wh\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442430>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Color_Hover_All_Boxes", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "18": {"suite_name": "test_Verify_Color_Hover_Manage_A_Books.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Color_Hover_Manage_A_Books>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmp0xso0f26\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442940>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Color_Hover_Manage_A_Books", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "19": {"suite_name": "test_Verify_ContactUsForm.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_ContactUsForm>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmp4ghut_pk\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442AF0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_ContactUsForm", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "20": {"suite_name": "test_Verify_DownloadAndOpenPdfFile.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_DownloadAndOpenPdfFile>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmphpz22xha\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442700>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_DownloadAndOpenPdfFile", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "21": {"suite_name": "test_Verify_Forgot_Login.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Forgot_Login_Successfully>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpl31ppbf5\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442670>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Forgot_Login_Successfully", "rerun": "0"}, "1": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Forgot_Login_Successfully>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpl31ppbf5\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442670>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Forgot_Login_Failed", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 2}}, "22": {"suite_name": "test_Verify_Mandatory_Fields_ContactUs.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Mandatory_Fields_ContactUs>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpvtj3v4vn\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442EE0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Mandatory_Fields_ContactUs", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "23": {"suite_name": "test_Verify_Order_Id.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_VerifyOrder>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmph45m6gr_\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807442DC0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_VerifyOrder", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "24": {"suite_name": "test_Verify_Specials_Offers.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Specials_Offers>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpa1tn63n7\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807E264C0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Specials_Offers", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "25": {"suite_name": "test_Verify_Testimonials.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_Verify_Testimonials>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmp83mnyvxc\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807E268B0>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_Verify_Testimonials", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "26": {"suite_name": "test_Verify_User_Has_Already_Been_Created.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_UserAlreadyBeenCreated>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpcm2cqn9e\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807E26550>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_UserAlreadyBeenCreated", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}, "27": {"suite_name": "test_Verify_WishList.py", "tests": {"0": {"status": "ERROR", "message": "request = <SubRequest 'test_setup' for <Function test_VerifyWishList>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        from selenium import webdriver\n        browser = request.config.getoption(\"--browser\")\n        if browser == 'chrome':\n            driver = webdriver.Chrome(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\chromedriver.exe\")\n        elif browser == 'firefox':\n>           driver = webdriver.Firefox(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe\")\n\n..\\conftest.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:151: in __init__\n    firefox_profile = FirefoxProfile(firefox_profile)\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\selenium\\webdriver\\firefox\\firefox_profile.py:79: in __init__\n    shutil.copytree(self.profile_dir, newprof,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc = 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\ndst = 'C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\tmpybxsi05c\\\\webdriver-py-profilecopy', symlinks = False\nignore = <function ignore_patterns.<locals>._ignore_patterns at 0x0000027807E26940>, copy_function = <function copy2 at 0x0000027804856700>\nignore_dangling_symlinks = False, dirs_exist_ok = False\n\n    def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n                 ignore_dangling_symlinks=False, dirs_exist_ok=False):\n        \"\"\"Recursively copy a directory tree and return the destination directory.\n    \n        dirs_exist_ok dictates whether to raise an exception in case dst or any\n        missing parent directory already exists.\n    \n        If exception(s) occur, an Error is raised with a list of reasons.\n    \n        If the optional symlinks flag is true, symbolic links in the\n        source tree result in symbolic links in the destination tree; if\n        it is false, the contents of the files pointed to by symbolic\n        links are copied. If the file pointed by the symlink doesn't\n        exist, an exception will be added in the list of errors raised in\n        an Error exception at the end of the copy process.\n    \n        You can set the optional ignore_dangling_symlinks flag to true if you\n        want to silence this exception. Notice that this has no effect on\n        platforms that don't support os.symlink.\n    \n        The optional ignore argument is a callable. If given, it\n        is called with the `src` parameter, which is the directory\n        being visited by copytree(), and `names` which is the list of\n        `src` contents, as returned by os.listdir():\n    \n            callable(src, names) -> ignored_names\n    \n        Since copytree() is called recursively, the callable will be\n        called once for each directory that is copied. It returns a\n        list of names relative to the `src` directory that should\n        not be copied.\n    \n        The optional copy_function argument is a callable that will be used\n        to copy each file. It will be called with the source path and the\n        destination path as arguments. By default, copy2() is used, but any\n        function that supports the same signature (like copy()) can be used.\n    \n        \"\"\"\n        sys.audit(\"shutil.copytree\", src, dst)\n>       with os.scandir(src) as itr:\nE       NotADirectoryError: [WinError 267] El nombre del directorio no es v\u00e1lido: 'C:\\\\Users\\\\admin\\\\PycharmProjects\\\\TercerProyecto\\\\Drivers\\\\geckodriver.exe'\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\shutil.py:555: NotADirectoryError\n", "test_name": "test_VerifyWishList", "rerun": "0"}}, "status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}}}}, "date": "January 19, 2022", "start_time": 1642601802.7752972, "total_suite": 28, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "29", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "29"}